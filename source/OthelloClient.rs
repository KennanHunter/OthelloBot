 /*************************************************************************
 * This file was generated by CRUST by an automated semantics preserving
 * translation from C/C++ to Rust
 * CRUST isn't perfect and may require manual editing
 * Check warnings and errors and refer to the official Rust Documentation
 ************************************************************************/
 // Othello Client Inferface
 // Included Libraries for C++ functions
 
/** Crust doesn't resolve C/C++ dependencies or included header.
* You may have to define your own module and implement those functionality in Rust 
* Or you can translate header file with Crust to produce Rust code. * 
* >>>>>>>> # include "sio_client.h" # include < functional >
 * >>>>>>>> # include < iostream >
 * >>>>>>>> # include < fstream >
 * >>>>>>>> # include < thread >
 * >>>>>>>> # include < mutex >
 * >>>>>>>> # include < condition_variable >
 * >>>>>>>> # include < string >
 * >>>>>>>> # include < utility >
 * >>>>>>>> # include < unordered_map >
 * >>>>>>>> # include < map >
 * >>>>>>>> # include "../include/OthelloClass.h" // Short hand print out with color # define EM ( __O__ ) std :: cout << "\e[1;30;1m" << __O__ << "\e[0m" << std :: endl // namespace identifier to simplify lines of code using namespace sio ; using namespace std ; // global variables std :: mutex _lock ; std :: string gTeamName ; std :: string gOpponentName ; std :: condition_variable_any _cond ; bool connect_finish = false ; bool game_over = false ; int timeout = 1 ; socket :: ptr current_socket ; // Connection Listener class class connection_listener { sio :: client & handler ; socket :: ptr socket_ ; string name_ ; public : connection_listener ( sio :: client & h , string n ) : handler ( h ) , name_ ( n ) { socket_ = h . socket ( ) ; } void on_connected ( ) { _lock . lock ( ) ; _cond . notify_all ( ) ; message :: ptr player_name = string_message :: create ( name_ ) ; message :: ptr data_out = object_message :: create ( ) ; data_out -> get_map ( ) . insert ( pair < string , message :: ptr >
 **/
 ( "name" ; player_name ) ) ; socket_ . emit ( "set team" , data_out ) ; connect_finish = true ; _lock . unlock ( ) ; fn on_close ( close_reason : client ) { std :: 
//This statement need to be handled manually 
 cout << "Socket Connection Closed" << std :: endl ; exit ( 0 ) ; } fn on_fail ( ) { std :: 
//This statement need to be handled manually 
 cout << "Socket IO Failed" << std :: endl ; exit ( 0 ) ; } ; fn ToString ( * : & mut spaceState ) -> String { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut strBoard : String = ""; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut i : i32 = 0; ; while i < 8 { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut j : i32 = 0; ; while j < 8 { //cout << inputBoard[i][j];
 strBoard = strBoard + to_string ( inputBoard [ i ] [ j ] ) ; //cout << " ";
 j +=1 ; } //cout << endl;
 i +=1 ; } 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 strBoard } spaceState * * ToArray ( string strBoard ) { spaceState * * gameBoard ; gameBoard = new ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 static mut charCount : i32 = 0; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 static mut i : i32 = 0; ; while i < 8 { gameBoard [ i ] = new spaceState [ 8 ] ; i +=1 ; } 
/*Avoid using mutable variables unless it is necessary to do so
 */
 static mut i : i32 = 0; ; while i < 8 { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 static mut j : i32 = 0; ; while j < 8 { gameBoard [ i ] [ j ] = EMPTY ; j +=1 ; } i +=1 ; } 
/*Avoid using mutable variables unless it is necessary to do so
 */
 static mut i : String = 0; ; while i < strBoard . size ( ) { gameBoard [ i / 8 ] [ i % 8 ] = static_cast < spaceState > ( strBoard [ i ] - '0' ) ; i +=1 ; } 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return gameBoard ; fn IsFirstMove ( * : & mut spaceState ) -> i32 { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut white_count : i32 = 0; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut black_count : i32 = 0; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut i : i32 = 0; ; while i < 8 { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut j : i32 = 0; ; while j < 8 { if ( input_board [ i ] [ j ] == BLACK ) == true { black_count +=1 ; } else if ( input_board [ i ] [ j ] == WHITE ) == true { white_count +=1 ; } j +=1 ; } i +=1 ; } if ( white_count == 1 && black_count == 4 ) == true { 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 return 1 ; } else { 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 0 } } fn bind_events ( ) { current_socket . on ( "set timeout" , sio :: socket :: event_listener_aux ( [ & ] ( string const & name , message :: ptr const & data , bool isAck , message :: list & ack_resp ) { _lock . lock ( ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut moveTimeout : i32 = data->get_map()["timeout"]->get_int(); ; EM ( "moveTimeout set to " << moveTimeout << " Seconds" ) ; 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let othelloBoard0 = Board { }; othelloBoard0 . moveTime_ = moveTimeout * 1000 ; _lock . unlock ( ) ; ) ) ; current_socket . on ( "set opponent" , sio :: socket :: event_listener_aux ( [ & ] ( string const & name , message :: ptr const & data , bool isAck , message :: list & ack_resp ) { _lock . lock ( ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut gameID : String = data->get_map()["game_id"]->get_string(); ; gOpponentName = data ; EM ( "Game ID set to " << gameID << " with opponent " << gOpponentName ) ; std :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let out = ofstream { }; out . open ( "GameLogs/" + gTeamName + "_" + gameID + ".txt" , std :: ios :: app ) ; out << gTeamName << " vs. " << gOpponentName << " gameID: " << gameID << std :: endl ; out . close ( ) ; _lock . unlock ( ) ; ) ) ; current_socket . on ( "make move" , sio :: socket :: event_listener_aux ( [ & ] ( string const & name , message :: ptr const & data , bool isAck , message :: list & ack_resp ) { _lock . lock ( ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut gameID : String = data->get_map()["game_id"]->get_string(); ; spaceState * * in_board = ToArray ( data -> get_map ( ) [ "board" ] -> get_string ( ) ) ; 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let turn = spaceState { }; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut turnStr : String = to_string(turn); ; std :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let out = ofstream { }; out . open ( "GameLogs/" + gTeamName + "_" + gameID + ".txt" , std :: ios :: app ) ; if ( turn == WHITE && IsFirstMove ( in_board ) == true { ) { 
//This statement need to be handled manually 
 out << "1:0000000000000000000000000001200000021000000000000000000000000000:their turn" << std :: endl ; } out << turnStr << ":" << ToString ( in_board ) << ":my turn" << std :: endl ; out . close ( ) ; // hook this up to the Othello Class to be able to calculate moves properly
 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let othelloBoard = Board { }; othelloBoard . setBoard ( in_board ) ; if ( turn != othelloBoard . turn ) == true { othelloBoard . switchTurn ( ) ; } 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut totalMoveCount : i32 = 0; ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut moveSelection : i32 = 0; ; spaceState * * * availableMoves ; spaceState * * objectBoard ; // return a full set of possible moves (max sized 64 moves)
 availableMoves = othelloBoard ; totalMoveCount = othelloBoard ; // if the current player has at least 1 move
 if ( totalMoveCount != 0 ) == true { // this function should be cut to request from the client VM
 moveSelection = othelloBoard ; // the new board is the old board with the selected move applied
 // updated the board, set the object value and display it
 objectBoard = availableMoves [ moveSelection - 1 ] ; othelloBoard . setBoard ( objectBoard ) ; // reset the no move count
 //cout << endl;
 spaceState * * out_board = othelloBoard . gameBoard ; // change the in_board to Board.gameBoard
 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut out_boardStr : String = ToString(out_board); ; //data_out->get_map()["game_id"]->set_string(gameID);
 message :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let game_id_out = ptr { }; message :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let board_out = ptr { }; message :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let data_out = ptr { }; data_out . get_map ( ) . insert ( pair < string , message :: ptr > ( "game_id" , game_id_out ) ) ; data_out . get_map ( ) . insert ( pair < string , message :: ptr > ( "board" , board_out ) ) ; out . open ( "GameLogs/" + gTeamName + "_" + gameID + ".txt" , std :: ios :: app ) ; out << to_string ( turn % 2 + 1 ) << ":" << out_boardStr << ":their turn" << std :: endl ; out . close ( ) ; current_socket . emit ( "move" , data_out ) ; } // the current count of moves is 0 for the current player
 else { message :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let game_id_out = ptr { }; message :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let data_out = ptr { }; data_out . get_map ( ) . insert ( pair < string , message :: ptr > ( "game_id" , game_id_out ) ) ; out . open ( "GameLogs/" + gTeamName + "_" + gameID + ".txt" , std :: ios :: app ) ; out << to_string ( turn % 2 + 1 ) << ":" << ToString ( in_board ) << ":their turn - I pass" << std :: endl ; out . close ( ) ; current_socket . emit ( "pass" , data_out ) ; } _lock . unlock ( ) ; ) ) ; current_socket . on ( "game ended" , sio :: socket :: event_listener_aux ( [ & ] ( string const & name , message :: ptr const & data , bool isAck , message :: list & ack_resp ) { _lock . lock ( ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut game_id : String = data->get_map()["game_id"]->get_string(); ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut black_count : i32 = data->get_map()["black_count"]->get_int(); ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut white_count : i32 = data->get_map()["white_count"]->get_int(); ; 
//This statement need to be handled manually 
 cout << "Game ended: B-" << black_count << " W-" << white_count << endl ; _lock . unlock ( ) ; ) ) ; current_socket . on ( "tournament ended" , sio :: socket :: event_listener_aux ( [ & ] ( string const & name , message :: ptr const & data , bool isAck , message :: list & ack_resp ) { _lock . lock ( ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut pname : String = data->get_map()["name"]->get_string(); ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut game_count : i32 = data->get_map()["game_count"]->get_int(); ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut win_count : i32 = data->get_map()["win_count"]->get_int(); ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut tie_count : i32 = data->get_map()["tie_count"]->get_int(); ; 
//This statement need to be handled manually 
 cout << "Tournament results for " << pname << " Games: " << game_count << endl ; 
//This statement need to be handled manually 
 cout << "Wins: " << win_count << " Losses: " << game_count - tie_count - win_count << " Ties: " << tie_count << endl ; game_over = true ; _lock . unlock ( ) ; ) ) ; } fn main ( ) { 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut argv: Vec<_> = std::env::args().collect(); let mut argc = argv.len(); sio :: 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let h = client { }; gTeamName = args [ 1 ] ; 
/** Declaration of a structure should be completed with initialization of it's fields
 * It should be in the following format
 * let variable:struct_name = struct_name { member1:value1, member2:value2,..}
 */ let l = connection_listener { }; h . set_open_listener ( std :: bind ( & connection_listener :: on_connected , & l ) ) ; h . set_close_listener ( std :: bind ( & connection_listener :: on_close , & l , std :: placeholders :: _1 ) ) ; h . set_fail_listener ( std :: bind ( & connection_listener :: on_fail , & l ) ) ; 
/*Avoid using mutable variables unless it is necessary to do so
 */
 let mut server_IP : String = args[2]; ; std :: 
//This statement need to be handled manually 
 cout << "connecting to: " << server_IP << ":8080" << std :: endl ; h . connect ( "http://" + server_IP + ":8080" ) ; _lock . lock ( ) ; if ( ! connect_finish ) == true { _cond . wait ( _lock ) ; } _lock . unlock ( ) ; current_socket = h ; bind_events ( ) ; while ( h . opened ( ) == true { && game_over  ; ) { h . sync_close ( ) ; } h . clear_con_listeners ( ) ; 
/** Crust tries to identify return statement and replace with rust equivalent
 * shorthand notation. If error found in this line, Please replace shorthand notation 
 * with return statement 
 **/
 std::process::exit( 0 ); }